package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
    "context"
    "fmt"
    "log"

    "github.com/randnull/posts-service/internal/graph/model"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, allowComments bool) (string, error) {
    post_id, err := r.Repo.Create(title, content, allowComments)

    if err != nil {
        log.Fatal(err)
    }

    return post_id, nil
}

// ChangeVisible is the resolver for the changeVisible field.
func (r *mutationResolver) ChangeVisible(ctx context.Context, postID string, allowComments *bool) (*model.Response, error) {
    err := r.Repo.ChangeCommentVisible(postID, *allowComments)

    if err != nil {
        return nil, err
    }

    return &model.Response{
        Status: "Ok",
        Desc: fmt.Sprintf("Comments is %b", allowComments),
    }, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*model.ResponseID, error) {
    comment, err := r.Repo.AddComment(postID, parentID, content)

    if err != nil {
        return nil, err
    }

    r.mu.Lock()
    defer r.mu.Unlock()

    chs, ok := r.commentObservers[postID]

    if ok {
        for _, ch := range chs {
            ch <- comment
        }
    }

    return &model.ResponseID{
        ID: comment.ID,
        Desc: "Created",
    }, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
    posts, err := r.Repo.GetAll()

    if err != nil {
        log.Fatal(err)
    }

    return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, postID string, startPage *int, pageSize *int) (*model.PostWithComments, error) {
    posts, err := r.Repo.GetPost(postID, startPage, pageSize)

    if err != nil {
        return nil, err
    }

    return posts, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
    ch := make(chan *model.Comment, 1)

    r.mu.Lock()
    r.commentObservers[postID] = append(r.commentObservers[postID], ch)
    r.mu.Unlock()

    go func() {
        <-ctx.Done()
        r.mu.Lock()
        defer r.mu.Unlock()

        chs := r.commentObservers[postID]

        for i, c := range chs {
            if c == ch {
                r.commentObservers[postID] = append(chs[:i], chs[i+1:]...)
                break
            }
        }

        close(ch)
    }()

    existingComments, err := r.Repo.GetPost(postID, nil, nil)
    if err != nil {
        return nil, err
    }

    for _, comment := range existingComments.Comments {
        ch <- comment
    }

    return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
